options {
  JAVA_UNICODE_ESCAPE = true;
  ERROR_REPORTING = false;
  STATIC = false;
  COMMON_TOKEN_ACTION = false;
  JDK_VERSION = "1.5";
}

PARSER_BEGIN(JsBeautyParser)
package org.liujing.parser.codeBeauty;

import org.liujing.parser.JsNode;
import java.io.*;
import java.util.logging.*;
import sidekick.*;
import javax.swing.tree.*;
import java.util.regex.*;
import errorlist.*;

public class JsBeautyParser
{
	public static Logger log = Logger.getLogger(JsBeautyParser.class.getName());
	private org.gjt.sp.jedit.Buffer buffer;
	private DefaultMutableTreeNode parentNode;
	private static Pattern lineNoP = Pattern.compile("line ([0-9]*)");
	private static Pattern columnP = Pattern.compile("column ([0-9]*)");
   public JsBeautyParser()
   {
      this(System.in);
      jj_input_stream.setTabSize(1);
   }
   public void parse(Reader is)throws Exception{
   	  try {
   	  	ReInit(is);
   	  	
      start();
      }catch(Exception e) {
      	throw e;
      }
   }
   public void parse(InputStream is)throws Exception{
   	  try {
   	  	ReInit(is);
   	  	
      start();
      }catch(Exception e) {
      	throw e;
      }
   }
   public void parse(String src)throws Exception{
   	  parse(new StringReader(src));
   }
   
   
   public SideKickParsedData parse(org.gjt.sp.jedit.Buffer buffer, errorlist.DefaultErrorSource errorSource)throws Exception
	{
		data=new SideKickParsedData(buffer.getName());
		try{
			this.buffer = buffer;
			parentNode = data.root;
			parse(buffer.getText(0,buffer.getLength()));
			
		}catch(ParseException e){
			log.log(Level.FINE,"parse failed",e);
			int line = 0, start = 0, end = 0;
			Matcher m = lineNoP.matcher(e.getMessage());
			if(m.find()){
				line = Integer.parseInt(m.group(1))-1;
			}
			m = columnP.matcher(e.getMessage());
			if(m.find()){
				start = Integer.parseInt(m.group(1));
				end = start + 1;
			}
			errorSource.addError(ErrorSource.ERROR, buffer.getPath(),line, start, end, e.getMessage());
		}catch(TokenMgrError te){
			errorSource.addError(ErrorSource.ERROR, buffer.getPath(),0,0,0, te.getMessage());
		}
		return data;
	}
}

PARSER_END(JsBeautyParser)

/* WHITE SPACE */

SKIP :
{
  " "
  |"\n"
| "\t"
| "\r"
| "\f"
}

/* COMMENTS */
MORE :
{
  /* danson, added backup(2) for special handling of single line comments at
  the end of a file, see <IN_SINGLE_LINE_COMMENT> special token below */
  "//" { input_stream.backup(2); } : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  /* this is the original, I've replaced with the next line to allow a single
  line comment at the end of a java file without a new line following the
  comment.  The java language specification says that single line comments
  must be followed by an end-of-line marker (see section 3.4), so this new rule
  relaxes that requirement slightly by allowing the line terminator to be
  optional.  This only makes sense when the comment is the last line of the
  source file, all other single line comments will have a line terminator. This
  request was posted as a bug against JBrowse, I don't see any problem with
  allowing it, especially since Sun's compiler doesn't complain. */
  /* <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT */
  < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<MULTI_LINE_COMMENT: "*/" >  : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
	"var"
	|"in"
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < WHILE: "while" >
| <TYPEOF:"typeof">
| <FUNCTION:"function">
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\" ( ["n","t","b","r","f","\\","'","\"","x","a"]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\" ( ["n","t","b","r","f","\\","'","\"","x","a"]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >

}

//MORE:{
//	<"/" ~["*","="]> { input_stream.backup(1); }:IN_REGEXP
//}
<IN_REGEXP>
MORE:{
	<~["/","\\"]>
	| <"\\" ~[] >
}
<IN_REGEXP>
TOKEN:{
	<REGEXP:<SLASH>(["a"-"z"])* > {
		//JsBeautyParser.log.info("match regexp "+image);
	} :DEFAULT
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "$",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| "==="
| "!=="
}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
| < RSIGNEDSHIFT: ">>" >
| < GT: ">" >
}

void start():
{}
{
	
	(BlockStatement())* <EOF>
}


void VariableDeclarator():
{
	String idTk = null;
	DefaultMutableTreeNode node = null;
}
{
	idTk=VariableDeclaratorId() [ "=" node=VariableInitializer() {
		if(node!=null){
			Object o = node.getUserObject();
			if(o instanceof JsNode){
				JsNode jsnode = (JsNode)o;
				jsnode.setName(idTk);
			}
		}
	} ]
}

String VariableDeclaratorId():
{
	Token id = null;
}
{
	id=<IDENTIFIER> (LOOKAHEAD(2) "[" "]" )* {return id.image;}
}

DefaultMutableTreeNode VariableInitializer():
{	DefaultMutableTreeNode node = null;}
{
	node=Expression() {return node;}
}

void ArrayInitializer():
{}
{
  "[" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "]"
}

/*
 * Type, name and expression syntax follows.
 */

void Type():
{}
{
  "var"
}



void ResultType():
{}
{
  "void"
|
  Type()
}

void Name():
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{}
{
  <IDENTIFIER>
  ( LOOKAHEAD(2) "."  <IDENTIFIER>
  )*
}

void NameList():
{}
{
  Name() ( "," Name() )*
}


/*
 * Expression syntax follows.
 */

DefaultMutableTreeNode Expression():
{
	DefaultMutableTreeNode[] nodes = new DefaultMutableTreeNode[1];
}
{
  ConditionalExpression(nodes) [   LOOKAHEAD(2) AssignmentOperator() Expression()]
  {return nodes[0];}
}


DefaultMutableTreeNode JSONExpression():
{
	DefaultMutableTreeNode node = null;
	DefaultMutableTreeNode subnode = null;
	
}
{
	
	{	DefaultMutableTreeNode oldParent = parentNode;
		parentNode = new DefaultMutableTreeNode("{}");
	}
	"{" [subnode=JSONObjectUnit() ("," subnode=JSONObjectUnit() )*] "}"
	{
		
		if(parentNode.getChildCount()>0){
			oldParent.add(parentNode);			
		}
		parentNode = oldParent;
		return node;
	}
	| "[" [Expression() ("," Expression())*] "]"
	{
		return node;
	}
}

DefaultMutableTreeNode JSONObjectUnit():
{
	Token jsonPName = null;
	DefaultMutableTreeNode node = null;
}
{
	(jsonPName=<IDENTIFIER>| jsonPName=<STRING_LITERAL>| jsonPName=<CHARACTER_LITERAL>)":" node = Expression()
	{
		if(node!=null){
			String newName = jsonPName.image;
			Object obj = node.getUserObject();
			if(obj instanceof JsNode){
				JsNode jsnode = (JsNode)obj;
				jsnode.setName(newName);
			}
		}
		return node;
	}
	
}

DefaultMutableTreeNode FunctionExpression():
{
	Token functionTk = null;
	Token functionName = null;
	Token end = null;
	DefaultMutableTreeNode oldParent = parentNode;
	DefaultMutableTreeNode subnode = null;
	String name = null;
	//log.info("FUNCTIONExpression start");
}
{
	functionTk="function" [functionName=<IDENTIFIER>]"(" [<IDENTIFIER>("," <IDENTIFIER>)*] end = ")" 
	{
		if(functionName!=null)
			name = functionName.image;
		else
			name = "<func>";
		if(buffer == null){
			subnode = new DefaultMutableTreeNode(name);
		}else{
			int offset = 
				buffer.getLineStartOffset(Math.max(functionTk.beginLine-1,0))
				+ functionTk.beginColumn-1;
			int endOff = 
			buffer.getLineStartOffset(Math.max(end.endLine-1,0))
				+ end.endColumn;
			//log.info("fun "+name+" "+end.beginColumn+" ~ "+end.endColumn);
			JsNode jnode = new JsNode(name,buffer.getText(offset,endOff-offset));		
			jnode.setStartOffset(offset);
			jnode.setEndOffset(endOff);
			//sidekick.util.ElementUtil.createStartPosition(buffer,jnode);
			//sidekick.util.ElementUtil.createEndPosition(buffer,jnode);
			subnode = new DefaultMutableTreeNode(jnode);
			//if(parentNode!=null)
			//log.info(name+"'s parent = "+parentNode.hashCode());
			parentNode.add(subnode);
			parentNode = subnode;
		}
		
	}
	Block()
	{
		
		//log.info(name+" block end, child:"+parentNode.getChildCount());
		parentNode = oldParent;
		return subnode;
	}
}

void AssignmentOperator():
{}
{
  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
}

void ConditionalExpression(DefaultMutableTreeNode[] nodes):
{}
{
  ConditionalOrExpression(nodes)[ "?" Expression() ":" Expression() ]
}

void ConditionalOrExpression(DefaultMutableTreeNode[] nodes):
{}
{
  ConditionalAndExpression( nodes)(  "||" ConditionalAndExpression( nodes) )*
}

void ConditionalAndExpression(DefaultMutableTreeNode[] nodes):
{}
{
  InclusiveOrExpression(nodes) (  "&&"   InclusiveOrExpression(nodes) )*
}

void InclusiveOrExpression(DefaultMutableTreeNode[] nodes):
{}
{
  ExclusiveOrExpression(nodes) (   "|"   ExclusiveOrExpression(nodes) )*
}

void ExclusiveOrExpression(DefaultMutableTreeNode[] nodes):
{}
{
  AndExpression(nodes) (  "^"  AndExpression(nodes) )*
}

void AndExpression(DefaultMutableTreeNode[] nodes):
{}
{
  EqualityExpression(nodes) (  "&"  EqualityExpression(nodes) )*
}

void EqualityExpression(DefaultMutableTreeNode[] nodes):
{}
{
  InstanceOfExpression(nodes) (  ( "==" | "!="|"==="|"in" |"!==" )  InstanceOfExpression(nodes) )*
}

void InstanceOfExpression(DefaultMutableTreeNode[] nodes):
{}
{
  RelationalExpression(nodes) [  "instanceof"  PrimaryExpression() ]
}

void RelationalExpression(DefaultMutableTreeNode[] nodes):
{}
{
  ShiftExpression(nodes) (  ( "<" | ">" | "<=" | ">=" )  ShiftExpression(nodes) )*
}

void ShiftExpression(DefaultMutableTreeNode[] nodes):
{}
{
  AdditiveExpression(nodes) (  ( "<<" | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() )  AdditiveExpression(nodes) )*
}

void AdditiveExpression(DefaultMutableTreeNode[] nodes):
{}
{
  MultiplicativeExpression(nodes) ( ( "+" | "-" ) MultiplicativeExpression(nodes) )*
}

void MultiplicativeExpression(DefaultMutableTreeNode[] nodes):
{}
{
  UnaryExpression(nodes) (LOOKAHEAD(2) ( "*" | "/" | "%" ) UnaryExpression(nodes) )*
}

void UnaryExpression(DefaultMutableTreeNode[] nodes):
{}
{
  ( "+" | "-" ) UnaryExpression(nodes)
 | "typeof"  UnaryExpression(nodes)
 | "void"  UnaryExpression(nodes)
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus(nodes)
}

void PreIncrementExpression():
{}
{
  "++" PrimaryExpression()
}

void PreDecrementExpression():
{}
{
  "--" PrimaryExpression()
}

void UnaryExpressionNotPlusMinus(DefaultMutableTreeNode[] nodes):
{}
{
  ( "~" | "!" ) UnaryExpression(nodes)
|
  PostfixExpression( nodes)
}
void PostfixExpression(DefaultMutableTreeNode[] nodes):
{Object o = null;}
{
  o= PrimaryExpression() [ "++" | "--" ]
  {
  	  if(o instanceof DefaultMutableTreeNode)
  	  	  nodes[0] = (DefaultMutableTreeNode)o;
  }
}



Object PrimaryExpression():
{
	DefaultMutableTreeNode node = null;
	Token tk = getToken(1);
	int startOffset = 0;
	if(buffer!=null){
		startOffset = buffer.getLineStartOffset(Math.max(tk.beginLine-1,0))
			+ tk.beginColumn-1;
	}
}
{
	node=PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
	{
		tk = getToken(0);
		if(node!=null){
			return node;
		}
		
		if(buffer!=null){
			int endOffset = buffer.getLineStartOffset(Math.max(tk.endLine-1,0))+tk.endColumn;
			return buffer.getText(startOffset,endOffset-startOffset);
		}else{
			return "";
		}
	}
}

void MemberSelector():
{}
{
  "." <IDENTIFIER>
}

DefaultMutableTreeNode PrimaryPrefix():
{
	DefaultMutableTreeNode node = null;
}
{
	node =Literal() {return node;}
|
  LOOKAHEAD( ( <IDENTIFIER> "." )* "this" )
  ( <IDENTIFIER> "." )*
  "this"
  {return node;}
|
"(" Expression()")"
  {return node;}
|
  AllocationExpression()
  {return node;}
|
  Name()
  {return node;}
}

void PrimarySuffix():
{}
{
  LOOKAHEAD("." "super" ".")
  "." "super"
|
  LOOKAHEAD("." "this")
  "." "this"
|
  LOOKAHEAD(2)
  "." AllocationExpression()
|
  LOOKAHEAD(3)
  MemberSelector()
|
  "[" Expression() "]"
|
  "." <IDENTIFIER>
|
  Arguments()
}

DefaultMutableTreeNode Literal():
{
	DefaultMutableTreeNode node = null;
}
{
  <INTEGER_LITERAL>{return node;}
|
  <FLOATING_POINT_LITERAL>{return node;}
|
  <CHARACTER_LITERAL>{return node;}
|
  <STRING_LITERAL>{return node;}
|
  BooleanLiteral(){return node;}
|
  NullLiteral() {return node;}
| 
	node=JSONExpression() {return node;}
|
	node=FunctionExpression(){return node;}
|
  RegExp() {return node;}
}

// "/" [  <REGEXP_PARAM:(["g","i","m"])+> ]
void RegExp():
{
	token_source.SwitchTo(IN_REGEXP);
}
{
	"/" <REGEXP>
}

void BooleanLiteral():
{}
{
  "true"
|
  "false"
}

void NullLiteral():
{}
{
  "null"
}

void Arguments():
{}
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList():
{}
{
  Expression() ( "," Expression() )*
}

void AllocationExpression():
{}
{
  "new" PrimaryExpression()
}
/*
 * Statement syntax follows.
 */

void Statement():
{
	DefaultMutableTreeNode node = null;
}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression()[";"]
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
//|
//  SynchronizedStatement()
|
  TryStatement()
}



void LabeledStatement():
{}
{
  <IDENTIFIER> ":" Statement()
}

void Block():
{}
{
  "{" ( BlockStatement() )* "}"
}

void BlockStatement():
{}
{
  LOOKAHEAD( Type() <IDENTIFIER> )
  LocalVariableDeclaration() 
|
  Statement()
}

void LocalVariableDeclaration():
{}
{
  Type() VariableDeclarator() ( "," VariableDeclarator() )* 
}

void EmptyStatement():
{}
{
  ";"
}

void StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{
	DefaultMutableTreeNode node = null;
	String name = null;
	Object prim = null;
}
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  prim=PrimaryExpression()
  [
    "++"
  |
    "--"
  |
    AssignmentOperator() node = Expression()
    {
    	if(node!=null && prim instanceof String){
    		name = (String)prim;
    		Object o = node.getUserObject();
    		if(o instanceof JsNode){
    			JsNode jsnode = (JsNode)o;
    			jsnode.setName(name);
    		}else{
    			node.setUserObject(name);
    		}
    	}
    }
  ]
}

void SwitchStatement():
{}
{
  "switch" "(" Expression() ")" "{"
    ( SwitchLabel() ( BlockStatement() )* )*
  "}"
}

void SwitchLabel():
{}
{
  "case" Expression() ":"
|
  "default" ":"
}

void IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
}

void WhileStatement():
{}
{
  "while" "(" Expression() ")" Statement()
}

void DoStatement():
{}
{
  "do" Statement() "while" "(" Expression() ")"
}

void ForStatement():
{}
{
  "for" "("
  (	
  	  LOOKAHEAD( [Type()] <IDENTIFIER> "in") [Type()] <IDENTIFIER> "in" Expression()
  	  | 
  	  [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ]
  )

  ")" Statement()
}

void ForInit():
{}
{
  LOOKAHEAD( Type() <IDENTIFIER> )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList():
{}
{
  StatementExpression() ( "," StatementExpression() )*
}

void ForUpdate():
{}
{
  StatementExpressionList()
}

void BreakStatement():
{}
{
  "break" [ LOOKAHEAD(2) <IDENTIFIER> ";" ] 
}

void ContinueStatement():
{}
{
  "continue" [ LOOKAHEAD(2) <IDENTIFIER> ";" ] 
}

void ReturnStatement():
{}
{
  "return" [ Expression() ] [";"]
}

void ThrowStatement():
{}
{
  "throw" Expression() [";"]
}

//void SynchronizedStatement():
//{}
//{
//  "synchronized" "(" Expression() ")" Block()
//}

void TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{}
{
  "try" Block()
  ( "catch" "(" <IDENTIFIER> ")" Block() )*
  [ "finally" Block() ]
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  <RUNSIGNEDSHIFT>
}

void RSIGNEDSHIFT():
{}
{
 <RSIGNEDSHIFT>
}

